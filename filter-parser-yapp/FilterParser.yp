# Header section

%{

use warnings;

%}

%%

# Rules section

# The top-level 'filter' rule:

filter: keyword expression
    {
        return [ @_[1..$#_] ];
    }
    ;

# Values

constant: string | number ;

value: string | number | identifier ;

value_list: value
          | operator value
            {
                return [ @_[1..$#_] ];
            }
          | value_list comma value
            {
                return [ @_[1..$#_] ];
            }
          | value_list comma operator value
            {
                return [ @_[1..$#_] ];
            }
          ;

value_zip: value value_zip_part
            {
                return [ @_[1..$#_] ];
            }
         | value operator value_zip_part
            {
                return [ @_[1..$#_] ];
            }
         | value_zip value_zip_part
            {
                return [ @_[1..$#_] ];
            }
         ;

value_zip_part: colon value
                {
                    return [ undef, $_[2] ];
                }
              | colon operator value
                {
                    return [ $_[1], $_[2] ];
                }
              ;

value_zip_list: value_zip
              | value_zip comma value_zip
                {
                    return [ @_[1..$#_] ];
                }
              ;

# Expressions

expression: expression_clause
          | expression_clause OR expression
            {
                return [ @_[1..$#_] ];
            }
          ;

expression_clause: expression_phrase
                 | expression_phrase AND expression_clause
                    {
                        return [ @_[1..$#_] ];
                    }
                 ;

expression_phrase: comparison
                 | predicate_comparison
                 | openingbrace expression closingbrace
                    {
                        return $_[2];
                    }
                 | NOT comparison
                    {
                        return [ @_[1..$#_] ];
                    }
                 | NOT predicate_comparison
                    {
                        return [ @_[1..$#_] ];
                    }
                 | NOT openingbrace expression closingbrace
                    {
                        return [ $_[1], $_[3] ];
                    }
                 ;

comparison: constant_first_comparison | identifier_first_comparison ;

identifier_first_comparison: identifier value_op_rhs
                                {
                                    return [ @_[1..$#_] ];
                                }
                           | identifier known_op_rhs
                                {
                                    return [ @_[1..$#_] ];
                                }
                           | identifier fuzzy_string_op_rhs
                                {
                                    return [ @_[1..$#_] ];
                                }
                           | identifier set_op_rhs
                                {
                                    return [ @_[1..$#_] ];
                                }
                           | identifier set_zip_op_rhs
                                {
                                    return [ @_[1..$#_] ];
                                }
                           ;

constant_first_comparison: constant value_op_rhs
                            {
                                return [ @_[1..$#_] ];
                            }
                         ;

predicate_comparison: length_comparison ;

value_op_rhs: operator value
                {
                    return [ @_[1..$#_] ];
                }
            ;

known_op_rhs: IS KNOWN
                {
                    return [ @_[1..$#_] ];
                }
            | IS UNKNOWN
                {
                    return [ @_[1..$#_] ];
                }
            ;

fuzzy_string_op_rhs: CONTAINS string
                        {
                            return [ @_[1..$#_] ];
                        }
                   | STARTS string
                        {
                            return [ @_[1..$#_] ];
                        }
                   | STARTS WITH string
                        {
                            return [ @_[1..$#_] ];
                        }
                   | ENDS string
                        {
                            return [ @_[1..$#_] ];
                        }
                   | ENDS WITH string
                        {
                            return [ @_[1..$#_] ];
                        }
                   ;

set_op_rhs: HAS value
            {
                return [ @_[1..$#_] ];
            }
          | HAS operator value
            {
                return [ @_[1..$#_] ];
            }
          | HAS ALL value_list
            {
                return [ @_[1..$#_] ];
            }
          | HAS EXACTLY value_list
            {
                return [ @_[1..$#_] ];
            }
          | HAS ANY value_list
            {
                return [ @_[1..$#_] ];
            }
          | HAS ONLY value_list
            {
                return [ @_[1..$#_] ];
            }
          ;

set_zip_op_rhs: identifier_zip_addon HAS value_zip
                {
                    return [ @_[1..$#_] ];
                }
              | identifier_zip_addon HAS ONLY value_zip_list
                {
                    return [ @_[1..$#_] ];
                }
              | identifier_zip_addon HAS ALL value_zip_list
                {
                    return [ @_[1..$#_] ];
                }
              | identifier_zip_addon HAS EXACTLY value_zip_list
                {
                    return [ @_[1..$#_] ];
                }
              | identifier_zip_addon HAS ANY value_zip_list
                {
                    return [ @_[1..$#_] ];
                }
              ;

length_comparison: LENGTH identifier operator value
                    {
                        return [ @_[1..$#_] ];
                    }
                 ;

identifier_zip_addon: colon identifier
                        {
                            return [ $_[2] ];
                        }
                    | identifierzipaddon colon identifier
                        {
                            return [ @$_[1], $_[3] ];
                        }
                    ;

# Separators

openingbrace: '(' ;

closingbrace: ')' ;

comma: ',' ;

colon: ':' ;

# OperatorComparison operator tokens

operator: '<'
        | '<' '='
            {
                return join( '', @_[1..$#_] );
            }
        | '>'
        | '>' '='
            {
                return join( '', @_[1..$#_] );
            }
        | '='
        | '!' '='
            {
                return join( '', @_[1..$#_] );
            }
    ;

%%

# Footer section

sub _Error
{
    my( $self ) = @_;
    close $self->{USER}{FILEIN} if $self->{USER}{FILEIN};
    my $msg = "$0: syntax error at line $self->{USER}{LINENO}, " .
              "position $self->{USER}{CHARNO}";
    if( $self->YYData->{INPUT} ) {
        $self->YYData->{INPUT} =~ s/\n$//;
        die "$msg: '" . $self->YYData->{INPUT} . "'.\n";
    } else {
        die "$msg.\n";
    }
}

sub _Lexer
{
    my( $self ) = @_;

    # If the line is empty and the input is originating from the file,
    # another line is read.
    if( !$self->YYData->{INPUT} && $self->{USER}{FILEIN} ) {
        my $filein = $self->{USER}{FILEIN};
        $self->YYData->{INPUT} = <$filein>;
        $self->{USER}{LINENO} = -1 unless exists $self->{USER}{LINENO};
        $self->{USER}{LINENO}++;
        $self->{USER}{CHARNO} = 0;
    }

    # Keyword must be a first lexem and can not be preceded by space,
    # thus it is handled exclusively by the lexer.
    if( $self->{USER}{LINENO} == 0 && $self->{USER}{CHARNO} == 0 ) {
        if( $self->YYData->{INPUT} =~ s/^(filter=)// ) {
            $self->{USER}{CHARNO} += length( $1 );
            return( 'keyword', $1 );
        } else {
            return( undef, undef ); # error
        }
    }

    $self->YYData->{INPUT} =~ s/^(\s+)//;
    $self->{USER}{CHARNO} += length( $1 ) if defined $1;

    # Escaped double quote or backslash are detected here and returned
    # as is to the caller in order to be detected as syntax errors.
    if( $self->YYData->{INPUT} =~ s/^(\\"|\\\\)// ) {
        $self->{USER}{CHARNO} += length( $1 );
        return( $1, $1 );
    }

    # Handling strings
    if( $self->YYData->{INPUT} =~ s/^(")// ) {
        my $string = $1;
        my $changed = 1;
        while( $changed ) {
            $changed = 0;
            if( $self->YYData->{INPUT} =~
                    s/^([A-Za-z_0-9 \t!#\$\%&\'\(\)\*\+,\-\.\/\:;<=>\?@\[\]\^`\{\|\}\~\P{ASCII}]+)// ) {
                $string .= $1;
                $changed = 1;
            }
            if( $self->YYData->{INPUT} =~ s/^(\\\\)// ) {
                $string .= $1;
                $changed = 1;
            }
            if( $self->YYData->{INPUT} =~ s/^(\\")// ) {
                $string .= $1;
                $changed = 1;
            }
            if( $self->YYData->{INPUT} =~ s/^(")// ) {
                $string .= $1;
                last;
            }
        }
        if( $string =~ /"$/ ) {
            $self->{USER}{CHARNO} += length( $string );
            return( 'string', $string );
        } else {
            return( undef, undef );
        }
    }

    # Handling identifiers
    if( $self->YYData->{INPUT} =~ s/^([a-z_][a-z0-9_]*)// ) {
        $self->{USER}{CHARNO} += length( $1 );
        return( 'identifier', $1 );
    }

    # Handling boolean relations
    if( $self->YYData->{INPUT} =~ s/^(AND|NOT|OR|
                                      IS|UNKNOWN|KNOWN|
                                      CONTAINS|STARTS|ENDS|WITH|
                                      LENGTH|HAS|ALL|ONLY|EXACTLY|ANY)//x ) {
        $self->{USER}{CHARNO} += length( $1 );
        return( $1, $1 );
    }

    # Handling numbers
    if( $self->YYData->{INPUT} =~ s/^([+-]?
                                     (\d+\.?\d*|\.\d+)
                                     ([eE][+-]?\d+)?)//x ) {
        $self->{USER}{CHARNO} += length( $1 );
        return( 'number', $1 );
    }

    my $char = substr( $self->YYData->{INPUT}, 0, 1 );
    if( $char ne '' ) {
        $self->YYData->{INPUT} = substr( $self->YYData->{INPUT}, 1 );
    }
    $self->{USER}{CHARNO}++;
    return( $char, $char );
}

sub Run
{
    my( $self, $filename ) = @_;
    open $self->{USER}{FILEIN}, $filename;
    my $result = $self->YYParse( yylex => \&_Lexer, yyerror => \&_Error );
    close $self->{USER}{FILEIN};
    return $result;
}

sub parse_string
{
    my( $self, $string ) = @_;
    $self->YYData->{INPUT} = $string;
    $self->{USER}{LINENO} = 0;
    $self->{USER}{CHARNO} = 0;
    return $self->YYParse( yylex => \&_Lexer, yyerror => \&_Error );
}

1;
