# Header section

%%

# Rules section

# The top-level 'filter' rule:

filter: keyword expression ;

# Keywords

keyword: 'f' 'i' 'l' 't' 'e' 'r' '=' ;

# Values

value: identifier | number | string ;

# The white-space:

space: ' ' | '\t' ;

# Boolean relations:

AND: 'A' 'N' 'D' ;
NOT: 'N' 'O' 'T' ;
OR: 'O' 'R' ;

# Expressions

expression: term
          | term OR expression ;

term: atom
    | atom AND term ;

atom: comparison
    | NOT comparison
    | '(' andcomparisons ')'
    | NOT '(' andcomparisons ')'
    ;

andcomparisons: andcomparison
              | andcomparison OR andcomparisons
              ;

andcomparison: comparison
             | NOT comparison
             | comparison comparisons
             | NOT comparison comparisons
             ;

comparisons: AND comparison
           | AND NOT comparison
           | AND comparison comparisons
           | AND NOT comparison comparisons
           ;

# Comparison operator tokens:

operator: '<'
        | '<' '='
        | '>'
        | '>' '='
        | '='
        | '!' '='
        ;

comparison: value operator value ;

# Identifier syntax

identifier: letter
          | identifier letter
          | identifier digit
          ;

letter:
    'A' | 'B' | 'C' | 'D' | 'E' | 'F' | 'G' | 'H' | 'I' | 'J' | 'K' | 'L' |
    'M' | 'N' | 'O' | 'P' | 'Q' | 'R' | 'S' | 'T' | 'U' | 'V' | 'W' | 'X' |
    'Y' | 'Z' | 'a' | 'b' | 'c' | 'd' | 'e' | 'f' | 'g' | 'h' | 'i' | 'j' |
    'k' | 'l' | 'm' | 'n' | 'o' | 'p' | 'q' | 'r' | 's' | 't' | 'u' | 'v' |
    'w' | 'x' | 'y' | 'z' | '_'
;

# Strings:

string: '"' escapedchars '"' ;

escapedchars: escapedchar
            | escapedchars escapedchar
            ;

escapedchar: unescapedchar
           | '\'' '"'
           | '\'' '\''
           ;

unescapedchar: letter
             | digit
             | space
             | punctuator
#            | unicodehighchar
             ;

punctuator:
    '!' | '#' | '$' | '%' | '&' | '\''| '(' | ')' | '*' | '+' | ',' | 
    '-' | '.' | '/' | ':' | ';' | '<' | '=' | '>' | '?' | '@' | '[' |
    ']' | '^' | '`' | '{' | '|' | '}' | '~'
;

# The 'UnicodeHighChar' specifies all Unicode characters above 0x7F;
# the syntax used is the onw compatible with Grammatica:

# unicodehighchar = ? [^\p{ASCII}] ? ;

# Number token syntax:

number: unsignednumber
      | sign unsignednumber
      ;

unsignednumber: digits exponent
              | digits '.' exponent
              | digits '.' digits exponent
              | '.' digits exponent;

exponent: # can be empty
        | 'e' digits
        | 'e' sign digits
        | 'E' digits
        | 'E' sign digits
        ;

sign: '+' | '-' ;

digits: digit
      | digits digit
      ;

digit: '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9' ;

%%

# Footer section

sub _Error
{
    use Data::Dumper;
    print Dumper( $_[0]->{STACK} );
    print Dumper( $_[0]->{TOKEN} );
    print Dumper( $_[0]->{USER} );
}

sub _Lexer
{
    my( $self ) = @_;

    if( !$self->YYData->{INPUT} ) {
        my $filein = $self->{USER}{FILEIN};
        $self->YYData->{INPUT} = <$filein>;
    }

    $self->YYData->{INPUT} =~ s/^\s+//;
    my $char = substr( $self->YYData->{INPUT}, 0, 1 );
    $self->YYData->{INPUT} = substr( $self->YYData->{INPUT}, 1 );
    return( $char, $char );
}

sub Run
{
    my( $self, $filename ) = @_;
    open( $self->{USER}{FILEIN}, $filename );
    $self->YYParse( yylex => \&_Lexer, yyerror => \&_Error,
                        yydebug => 0x1f );
}

1;
